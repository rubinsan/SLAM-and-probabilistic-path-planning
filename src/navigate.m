function navigate(exploredMap,controller,diffDrive,lastPose,origin,fig1,fig2)
% This function obtains a valid path based on the map generated by
% a Voronoi diagram. The robot then returns to the origin of the exploration
% using this path.

index = 0; % index to save the coordinates of the obstacles
initPose(1:2) = lastPose(1:2) + 0.1; % The last position of the exploration is loaded as the first position
initPose(3) = lastPose(3) * -1; % a 180º turn is simulated on itself 
lastPos = round(lastPose(1:2));

occMatrix = checkOccupancy(exploredMap);
[mapdimx,mapdimy] = size(occMatrix);
%borderless_occMatrix = occMatrix(11:rows-10,11:cols-10); % Cells that cannot be sensed (external edges) are eliminated

% OBTAINING THE COORDINATES OF THE OBSTACLES
%[mapdimx,mapdimy] = size(borderless_occMatrix);
xy = zeros((2*(mapdimy+mapdimx)),2); % obstacles positions
for c = 1:mapdimx
    for r = 1:mapdimy
        if (occMatrix(c, r) == 1)
            index = index + 1;
            xy(index,:)  = 0.1*[r, mapdimx-c]; % obstacle coords (x,y) in coord local (*0.1 due to resolution)
        end
    end
end

map = binaryOccupancyMap(occMatrix,10);
figure('Name','Voronoi Points'); 
subplot (2,2,[1,3]);
show(map);
hold on

% OBTAINING POSSIBLE WAYPOINTS ON THE PATH BACK TO THE ORIGIN.
% USING A VORONOI DIAGRAM
[vx, vy] = voronoi(xy(:,1),xy(:,2));

possible_waypoint(:,1) = vx(1,:)';
possible_waypoint(:,2) = vy(1,:)';
plot(possible_waypoint(:,1) , possible_waypoint(:,2),'r*')
title('Generated points');
hold off

% Elimination of points generated near obstacles
for k = 1:length(possible_waypoint) % each possible waypoint will be compared
    for w = 1:length(xy) % with all the obstacles
        d = norm(possible_waypoint(k,:)-xy(w,:));
        if (d<1.1 || possible_waypoint(k,1)<=0 || possible_waypoint(k,2)<=0) % If the distance is less than 1.1 meters or negative coordinates are discarded
            possible_waypoint(k,:) = -1;
            break;    
        end
    end
end 

idxx = find(possible_waypoint >= 0);
[rows, cols] = ind2sub(size(possible_waypoint),idxx);
rows = rows(1:(length(rows)/2));

possible_waypoint = possible_waypoint(rows,:); 
subplot (2,2,2);
show(map);
hold on
plot(possible_waypoint(:,1) , possible_waypoint(:,2),'b*')
title('Filtered by distance to objects');
hold off

% Reduction of the number of possible points to speed up subsequent calculations
indxx = (1:20:length(possible_waypoint)); 
possible_waypoint = round(possible_waypoint(indxx,:),1);
subplot (2,2,4);
show(map);
hold on
plot(possible_waypoint(:,1) , possible_waypoint(:,2),'g*')
title('Possible final waypoints');

hold off
figure('Name','Waypoints Graph Figure'); 
show(map);
title('Generating the path back to the origin using a graph');
hold on
plot(possible_waypoint(:,1) , possible_waypoint(:,2),'g*')


%-------------------------------------------------------------------------
% GRAPH GENERATION TO OBTAIN A VALID PATH TO THE ORIGIN
G = graph([[],[]]);

% the starting point (last position in the scan) is inserted
startPoint = sub2ind([mapdimy,mapdimx],lastPos(1)*10,lastPos(2)*10);
G = addnode(G,num2str(startPoint));
[startPoint_row,startPoint_col] = ind2sub([mapdimy,mapdimx],startPoint);
%origin_lin = sub2ind([mapdimy,mapdimx],origin(1)*10,origin(2)*10);

while (~isempty(possible_waypoint)) 
    
    % It works on subscripts that are in possible_waypoint
    pos_wayPt = possible_waypoint(1,:); % a point is extracted to be evaluated
    p_col = pos_wayPt(1);
    p_row = pos_wayPt(2);
    
    p_sample=plot(p_col,p_row,'r*');   
    possible_waypoint(1,:) = [];% is removed from the set
    
    % dreturns the node of the graph (G) closest to the evaluated poss_waypoint
    node = nearest(G,[p_col,p_row],mapdimx,mapdimy,xy);
    
    % If there is no closer one because there is an obstacle: in the first point the probability 
    % that there is no direct path to the closest node (first) is very high
    if (isempty(node)) % If none exists, it puts it in the queue
        possible_waypoint = [possible_waypoint;pos_wayPt];
        set(p_sample,'Visible','off')
        continue;
    end
    
    % the node coordinates are obtained
    [node_row,node_col] = ind2sub([mapdimy,mapdimx],node);
    plot(node_row/10,node_col/10,'b*'); % Divide by 10 by the resolution                            
    
    % The path is added to the graph as well as the new node (pos_wayPt)
    % It is passed to a linear index to enter the graph       
    pos_wayPt_ind = sub2ind([mapdimy,mapdimx],p_col*10,p_row*10); % is multiplied by 10 by the resolution
    G = addedge(G,num2str(node),num2str(pos_wayPt_ind),[1]);
    plot([p_col,node_row/10],[p_row,node_col/10]);
    
    drawnow;
end

% The end point (origin of the map exploration) is added
node = nearest(G,origin,mapdimx,mapdimy,xy);
if (isempty(node))
    fprintf('CAN NOT CONNECT GOAL POINT\n\tIncrease the sampling...')
    return;
else
    [node_row,node_col] = ind2sub([mapdimy,mapdimx],node);
    origin_lin = sub2ind([mapdimy,mapdimx],origin(1)*10,origin(2)*10);
    G = addedge(G,num2str(node),num2str(origin_lin),[1]);
    plot([node_col/10,origin(2)],[node_row/10,origin(1)]);
end

% The function returns the shortest path of the graph between the origin (last
% pose of exploration) and the goal (origin of exploration)
P = shortestpath(G,num2str(startPoint),num2str(origin_lin));
[m,n] = size(P);
waypoints = zeros(n,2);

for i=1:n-1 % the final path is plotted and the waypoints are saved
    [r, c] = ind2sub([mapdimy,mapdimx],str2num(P{i}));
    p1 = [r/10, c/10];
    waypoints(i,:) = p1;
    [r, c] = ind2sub([mapdimy,mapdimx],str2num(P{i+1}));
    p2 = [r/10, c/10];
    plot([p1(1),p2(1)],[p1(2),p2(2)],'-og');   
end
waypoints(n,:) = p2; % final point is added
disp(waypoints)
hold off


%-----------------------------------------------------------------------
% NAVIGATION TO THE ORIGIN OF THE MAP
controller.Waypoints = waypoints;
controller.LookaheadDistance = 0.5;
disp(controller.Waypoints)

sampleTime = 0.05;            % Sample time [s]
t = 0:sampleTime:100;         % Time array
poses = zeros(3,numel(t));    % Pose matrix
poses(:,1) = initPose';

% set rate to iterate at
r = rateControl(1/sampleTime);

% Get the axes from the figures
ax1 = fig1.CurrentAxes;
ax2 = fig2.CurrentAxes;

for idx = 1:numel(t)
    
    % new pose
    position = poses(:,idx)';
    currPose = position(1:2);
    
    % End path following if vehicle has reached goal position within tolerance of 0.2m
    
    dist = norm(origin-currPose);
    if (dist < .4)
        disp("Goal position reached")
        break;
    end
    
    % Run the Pure Pursuit controller and convert output to wheel speeds
    [vRef,wRef] = controller(poses(:,idx));

    % Perform forward discrete integration step
    vel = derivative(diffDrive, poses(:,idx), [vRef wRef]);
    
    poses(:,idx+1) = poses(:,idx) + vel*sampleTime; % new pose = actual pose + integral on sampletime

    figure(4)
    show(exploredMap);
    title('Generated map navigation to the origin');
    hold on
    plot(controller.Waypoints(:,1),controller.Waypoints(:,2), 'o-');
    hold off  
    
    % Update visualization
    plotTrvec = [poses(1:2, idx+1); 0];
    plotRot = axang2quat([0 0 1 poses(3, idx+1)]);
    
    % Delete image of the last robot to prevent displaying multiple robots
    if idx > 1
       items = get(ax1, 'Children');
       delete(items(1)); 
    end

    % Plot robot onto known map
    plotTransforms(plotTrvec', plotRot, 'MeshFilePath', 'groundvehicle.stl', 'View', '2D', 'FrameSize', 1, 'Parent', ax1);
    % Plot robot on new map
    plotTransforms(plotTrvec', plotRot, 'MeshFilePath', 'groundvehicle.stl', 'View', '2D', 'FrameSize', 1, 'Parent', ax2);

    % Wait to iterate at the proper rate
    waitfor(r);
end


% --------------------FUNCION NEAREST -------------------------------
% returns the ith node of the S(G) nearest to the sampled point alpha-i
function node = nearest(G, p_sampled,rows,cols,xy)
    S=G;
    min_dist = intmax;
    p_min_dist = [];
    for ind = 1:S.numnodes
        pidx = str2num(S.Nodes(ind,1).Name{1});       
        p_i = str2num(S.Nodes(ind,1).Name{1});
        [p_r, p_c] = ind2sub([cols,rows],p_i);
        p = [p_r/10, p_c/10];
        
        if ~viablepath([p_sampled(1), p_sampled(2)],p,xy)
            continue;
        end
        
        distance = norm(p-p_sampled);
        if (distance < min_dist) 
            min_dist = distance;
            p_min_dist = pidx;
        end   
    end
    node = p_min_dist;
end
%---------------------------------------------------------------------

end

